---
title: "Broad Single Cell data"
author: "ks"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(Matrix)
library(purrr)
```

## Data source

https://singlecell.broadinstitute.org/single_cell

Search by text: SCP259
patient with UC (=ulcerative colitis)
https://singlecell.broadinstitute.org/single_cell/study/SCP259/intra-and-inter-cellular-rewiring-of-the-human-colon-during-ulcerative-colitis#study-download

```{r SCP259}
# Install and load the Seurat package if you haven't already
# install.packages("Seurat")
library(Seurat)

# 1. Define the paths to your three files
# NOTE: Replace these with the actual paths on your system
mtx_path <- "/Users/kims/OneDrive - University of Southern California/data/plasticity/broad-sc/SCP259/expression/5cdc540d328cee7a2efc2348/gene_sorted-Epi.matrix.mtx"
features_path <- "/Users/kims/OneDrive - University of Southern California/data/plasticity/broad-sc/SCP259/expression/5cdc540d328cee7a2efc2348/Epi.genes.tsv"
barcodes_path <- "/Users/kims/OneDrive - University of Southern California/data/plasticity/broad-sc/SCP259/expression/5cdc540d328cee7a2efc2348/Epi.barcodes2.tsv"

# 2. Read the files using ReadMtx()
counts_matrix <- ReadMtx(
  mtx = mtx_path,
  cells = barcodes_path,
  features = features_path,
  feature.column = 1 
)

# 3. View the structure (should be a sparse matrix)
dim(counts_matrix)
head(counts_matrix)[1:5, 1:5]
```

## Read in metadata

```{r read-metadata}
fn <- "/Users/kims/OneDrive - University of Southern California/data/plasticity/broad-sc/SCP259/metadata/all.meta2.txt"


# --- 2. Read the Header Row ---
# Read only 1 row, ensuring 'header=TRUE' is respected
header_dt <- fread(fn, nrows = 1, header = TRUE)

# --- 3. Read the Data starting from the 3rd physical row ---
meta_dt <- fread(fn, skip = 2, header = FALSE)

# --- 4. Assign the Header and Combine ---
# Set the column names of the data body using the names from the header
setnames(meta_dt, names(header_dt))

print(meta_dt)
```

Subset meta data to epithelial cells, and count numbers of epithelial cell types. 
```{r}
meta_epi <- meta_dt[match(colnames(counts_matrix),meta_dt$NAME),]
dim(meta_epi)
# check that I have the correct row order of meta_epi
identical(meta_epi$NAME,colnames(counts_matrix))
```

```{r}
table(meta_epi$Cluster)
sum(table(meta_epi$Cluster))
length(meta_epi$Cluster)
```
Interesting. The Cycling TA, TA 1 and TA 2 counts on the tSNE plot differ. Those are 14881 for all 3 categories. I'm going to think these are correct because the sum of all counts gives the correct total of 123006, and it would be very bizarre to get the same number of cells of different types (14881 three times).

Check out other meta data columns.  Data are from 30 subjects (12 healthy, 18 UC).
publication: https://www.cell.com/cell/fulltext/S0092-8674(19)30732-9
```{r}
length(unique(meta_epi$Subject))
table(meta_epi$Subject,meta_epi$Health)
table(meta_epi$Health)
```

50258 cells from healthy colon.

I need to split the count matrix into a matrix of cells from healthy colons and a matrix of cells from UC patients.  Let's do one at a time because the data are so big.

```{r}
counts_healthy_subj <- counts_matrix[,meta_epi$Health=="Healthy"]
dim(counts_healthy_subj)
meta_epi_healthy_subj <- meta_epi[meta_epi$Health=="Healthy",]
dim(meta_epi_healthy_subj)

#counts_uc_subj <- counts_matrix[,meta_epi$Health!="Healthy"]
#dim(counts_uc_subj)
#meta_epi_uc_subj <- meta_epi[meta_epi$Health!="Healthy",]
#dim(meta_epi_uc_subj)
rm(counts_matrix)
```

Darryl's TP10k = counts / cells total counts * 10k
This is also the formula used in the paper.  Kelly suggest we consider using sctransform instead. sctransform is the standard normalization method used by Seurat.
```{r}
cs <- colSums(counts_healthy_subj)
t1 <- Sys.time()
TP10k <- t( t(counts_healthy_subj) / cs )*10000
t2 <- Sys.time()
t2-t1
log1pTP10k_healthy <- log( 1 + TP10k[,1:25000])
log1pTP10k_healthy2 <- log( 1 + TP10k[,25001:ncol(TP10k)])
rm(TP10k)
log1pTP10k_healthy <- cbind(log1pTP10k_healthy,log1pTP10k_healthy2)
t3 <- Sys.time()
t3-t2
rm(log1pTP10k_healthy2)
```
This is darryl's log calculation.  Gemini says log_e is most common, but the original publication with this data used log_2. 

Also, these counts are not batch corrected, and the paper mentions doing a batch correction for tSNE plots and PCA because subjects result in a batch effect.

What are the proportions of the different epithelial cell types across the 12 subjects?
```{r}
tab <- table(meta_epi_healthy_subj$Cluster,meta_epi_healthy_subj$Subject)
tab
```

```{r}
cs <- colSums(tab)
prps <- t( round( t(tab) / cs ,3))
apply(prps,2,sum)
prps
```

For each cell type, estimate the mean expression from a random effects model with subject as a random effect. Now that I have log-transformed count data, should I use limma?  How many healthy cells were there?
```{r}
dim(counts_healthy_subj)
```
50k cells

Let's compute the mean by cell type.  Let's write this as a function I will use later.
I have a factor variable, and want to sum the values in my matrix over the levels of the factor variable (in columns). Here the matrix is log-normalized counts of gene expression. The columns are cell types.
```{r}

sumM_over_groups <- function(dt, group.var, avg = TRUE){
  
      # 1. Create the Grouping Matrix (G)
      # sparse.model.matrix creates the indicator matrix efficiently
      G <- sparse.model.matrix(~ 0 + group.var)
      colnames(G) <- levels(group.var)
       
      # 2. Calculate Column Sums for each group
      M_sum <- dt %*% G

      if (avg) {
        # 3. Calculate Group Sizes
        group_sizes <- colSums(G)
      
        # 4. Normalize (Divide by group sizes)
        M_avg <- t( t(M_sum) / group_sizes)
        return(M_avg)
      } else {
        return(M_sum)
      }
}

cell_type <- factor(meta_epi_healthy_subj$Cluster)
M_avg <- sumM_over_groups(log1pTP10k_healthy,cell_type,avg=TRUE)


print(head(M_avg[, 1:2]))
```

yes! This is darryl's file means_log1p_TP10k_by_celltype_Healthy.csv

Darryl wanted gene variance across cell types. Because there is variance due to batch,
I want to compute the variance for each subject, and then average over subjects. First, let me write a function to get variance in sets of columns (by subject).

```{r}
varM_over_groups <- function(dt_avg, group.var){
      # 1/(n-1) {sum xi^2 - n xbar^2}
      #group.var <- subj
      ni <- c(table(group.var))
  
      dt_avgsq <- dt_avg^2
      #dt_avgsq <- M_avg_celltype_subj^2
      term1 <- sumM_over_groups(dt_avgsq,group.var, avg = FALSE)
  
      xbar <- sumM_over_groups(dt_avg,group.var, avg = TRUE)
      term2 <- xbar^2 
      term2  <- t( t(term2) * ni )
      
      varM <- t( t(term1 - term2) / (ni - 1))
      varM
}
```


Compute average expression by cell type and subject. 
```{r}
celltype_subj <- factor(paste(meta_epi_healthy_subj$Cluster,
                                meta_epi_healthy_subj$Subject,sep="_"))
M_avg_celltype_subj <- sumM_over_groups(log1pTP10k_healthy,celltype_subj,avg=TRUE)

print(head(M_avg_celltype_subj[, 1:2]))
```

Compute variance by subject.

Create covariates for my columns.
```{r make-pheno}
covars <- strsplit(colnames(M_avg_celltype_subj),"_")
cell_type <- unlist(lapply(covars,pluck,1))
subj <- unlist(lapply(covars,pluck,2))
table(cell_type)
table(subj)
```

7 subjects have 15 cell types and 5 subjects only have 14 cell types.

Then we can compute gene variance across cell types for each subject and average over subjects.
```{r}
subj <- factor(subj)
subj_celltypeVar <- varM_over_groups(M_avg_celltype_subj,subj)
avg_celltypeVar <- apply(subj_celltypeVar,1,mean)
naive_celltypeVar <- apply(M_avg,1,var)
```


```{r}
plot(avg_celltypeVar,naive_celltypeVar)
abline(0,1,col=2)
```



