---
title: "Gene annotations using Refseq"
author: "ks"
date: "2025-10-31"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries}
library(GenomicFeatures)
library(AnnotationDbi)
library(rtracklayer)
#BiocManager::install("TxDb.Hsapiens.UCSC.hg38.knownGene")
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(data.table)
library(biomaRt)
#BiocManager::install("GenomicFeatures")
library(GenomicFeatures)
```



Let's compare this to the files Darryl downloaded:

```{r}
adir <- c("~kims/github/sandbox/bsseq/data/annotation")
gencodev48 <- fread(file.path(adir,"ucsc_hg38_gene_known_genecodeV48"))
gencodev48
```

```{r}
length(unique(gencodev48$`#name`))
```

```{r tss}
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
txdb
```
```{r ntx}
# Extract transcripts as a GRanges object
tx_gr <- transcripts(txdb)
tx_gr
# how many tx?
length(names(tx_gr))
```

Save chr1-22, X,Y and then subset to those with refseqid and hgnc

```{r}
desired_chromosomes <- paste0("chr",c(as.character(1:22), "X", "Y"))
# Assuming your GRanges object is called granges_obj
tx_gr <- tx_gr[seqnames(tx_gr) %in% desired_chromosomes]
length(tx_gr)
seqlevels(tx_gr) <- seqlevelsInUse(tx_gr)
```

Use biomaRt
```{r}
# Connect to Ensembl
ensembl <- useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")

searchAttributes(mart = ensembl, pattern = "hgnc")
searchAttributes(mart = ensembl, pattern = "refseq")
```


 
```{r}
# Example: your Ensembl gene IDs
ensembl_id <- values(tx_gr)$tx_name  

# Get corresponding RefSeq IDs
hgnc_mapping <- getBM(
  attributes = c(
    "ensembl_transcript_id_version", # The ENST ID you provide
    "hgnc_trans_name",               # hgnc transcript name
    "hgnc_symbol",                     # hgnc symbol
    "hgnc_id"
  ),
  filters = "ensembl_transcript_id_version",
  values = ensembl_id,
  mart = ensembl
)
hgnc_mapping

refseq_mapping <- getBM(
  attributes = c(
    "ensembl_transcript_id_version", # The ENST ID you provide
    "refseq_mrna",
    "refseq_mrna_predicted",
    "refseq_ncrna_predicted"
  ),
  filters = "ensembl_transcript_id_version",
  values = ensembl_id,
  mart = ensembl
)
refseq_mapping
```


```{r}
tx_dt <- as.data.table(tx_gr)
#tx_dt

tx_annot <- 
      merge(tx_dt,hgnc_mapping,
      by.x="tx_name", by.y = "ensembl_transcript_id_version")
tx_annot
```

I forgot to get coding start/end
```{r}
cds_by_tx <- cdsBy(txdb, by = "tx", use.names = TRUE)
```

Why is this shorter than the tx_name list itself?

```{r}
length(names(cds_by_tx))
```

```{r}
midx <- which(!is.element(tx_annot$tx_name,names(cds_by_tx)))
```
I think it's missing singleton exon/genes

```{r}
#library(parallel)
temp <- mclapply(cds_by_tx[1:500],length)
```



What if I look at his file using refseq names?

```{r}
temprefseq <- fread(file.path(adir,"ucsc_hg38_gene_known_RefSeqALL.txt"))
temprefseq
```
This is half the size (197654 rows not 412k).

Look at Rows 2 & 3. The only difference is the end of 1 exon.  What does this look like in the larger dataset?
```{r}
gencodev48[chrom=="chr1" & txStart==67092164 ]

temprefseq[chrom=="chr1" & txStart==67092164 ]
```


It includes alt chromosomes
```{r}
length(unique(temprefseq$chrom))
```

Can I find this directly using R?  I want to download RefSeq knowngene hg38 data from ucsc in R

```{r}
gtf_url <- "https://hgdownload.soe.ucsc.edu/goldenPath/hg38/bigZips/genes/hg38.ncbiRefSeq.gtf.gz"
refseq_gtf <- rtracklayer::import(gtf_url)
refseq_gtf <- refseq_gtf[values(refseq_gtf)$type=="transcript"]
refseq_gtf <- sort(refseq_gtf)
refseq_gtf
```

```{r}
refseq_gtf[start(refseq_gtf)==67092165]
```

Note: this has txStart End, but not cdsStart End.

This time mine is larger.  How many names overlap?
```{r}
is.element(c(2,3,4,6,7),c(3,4,9,10))
table(is.element(temprefseq$name,
           values(refseq_gtf)$transcript_id))
mean(is.element(temprefseq$name,
           values(refseq_gtf)$transcript_id))
```
91% of Darryl's transcript IDs are in my data set, but mine is larger.


Let's see what ChatGPT suggested to Darryl:
Yep — you used UCSC RefSeq → HGNC via a mapping table (refGene.txt or refFlat.txt) and matched by geneSymbol or name2.
You then merged with an HGNC complete set (hgnc_complete_set.txt) using symbol or alias_symbol.
Usually done with awk or a short Python/NumPy lookup.


```{r}
gtf_url <- "http://hgdownload.soe.ucsc.edu/goldenPath/hg38/database/refFlat.txt.gz"
refF <- fread(gtf_url)

names(refF) <- c("geneName","name","chrom","strand","txStart","txEnd","cdsStart","cdsEnd","exonCount","exonStarts","exonEnds")
refF
```

refF.txt and refGene.txt.gz contain the same names and records.

```{r}
table(is.element(refF$geneName,temprefseq$name2))
mean(is.element(refF$geneName,temprefseq$name2))
```
Most of these are in temprefseq, but there are extras that are not.


ChatGPT was providing annotation, but not the new data appearing in Darryl's file: ucsc_hg38_gene_known_RefSeqALL.txt.

How about some metadata files for V48 (https://www.gencodegenes.org/human/release_48.html)
download:  gencode.v48.metadata.RefSeq.gz
These give names, but don't have both tx and cds start/end positions.

```{r}
temp
```

Take darryl's first file, and try renaming transcripts from Ensemble to RefSeq mrna names.



```{r}
# Example: your Ensembl gene IDs
ensembl_id <- gencodev48$`#name`  

# Get corresponding RefSeq IDs
hgnc_mapping <- getBM(
  attributes = c(
    "ensembl_transcript_id_version", # The ENST ID you provide
    "hgnc_trans_name",               # hgnc transcript name
    "hgnc_symbol",                     # hgnc symbol
    "hgnc_id"
  ),
  filters = "ensembl_transcript_id_version",
  values = ensembl_id,
  mart = ensembl
)
hgnc_mapping

refseq_mapping <- getBM(
  attributes = c(
    "ensembl_transcript_id_version", # The ENST ID you provide
    "refseq_mrna",
    "refseq_mrna_predicted",
    "refseq_ncrna_predicted"
  ),
  filters = "ensembl_transcript_id_version",
  values = ensembl_id,
  mart = ensembl
)
refseq_mapping
```
When I map ensembl to refseq, I can get multiple predicted mrna for a single ensemble transcript. Does Darryl have multiple ensembl transcripts in his dataset? Let me look for duplicate mrnas.  I'll start with this one.

```{r}
gencodev48[`#name` == "ENST00000378486.8"]
sn <- unlist(lapply(strsplit(temprefseq$name,"[.]"),pluck,1))
temprefseq[ sn == "NM_001303013"]
```

Does darryl have refseq predicted?
```{r}
table(substr(temprefseq$name,1,2))
```

Yes.

Let's find his duplicates
```{r}
table(table(temprefseq$name))
```

180086 are unique Refseq ids.
One id has 47 replicates!
```{r}
which(table(temprefseq$name)==47)
```

```{r}
temprefseq[name=="NM_001242867.2"]
#temprefseq[name=="NM_006737.4"]
#temprefseq[name=="NM_153443.5"]
```


```{r}
length(unique(gencodev48$`#name`))
length(ensembl_id)
length(unique(hgnc_mapping$ensembl_transcript_id_version))
nrow(hgnc_mapping)
```

Now merge these names with gencodev48, and see if we get his Refseq data out...
```{r}

```




########
## getting TSS flanking intervals
########

Get transcription start sites:
```{r tss}
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene

transcripts_gr <- transcripts(txdb)
tss_gr <- resize(transcripts_gr, width = 1, fix = "start")
transcripts_gr
head(start(tss_gr))
tail(start(tss_gr))
```

Start() picked the upstream location depending on the strand information.

```{r get-gene-level-tss}
# Map transcript IDs to gene IDs
gene_tx_map <- AnnotationDbi::select(txdb, keys = as.character(transcripts_gr$tx_id), 
                                     columns = "GENEID", keytype = "TXID")
# Add gene IDs to the TSS GRanges object
tss_gr$gene_id <- gene_tx_map$GENEID[match(as.character(transcripts_gr$tx_id),
                                           gene_tx_map$TXID)]

#Drop rows with missing geneids
tss_gr <- tss_gr[!is.na(tss_gr$gene_id)]
length(tss_gr)
```

These are for all transcripts. I want to reduce them to genes.

First, restrict to chromosomes 1-22, X, Y.  I only want to select TSSs that are
on the primary assembly.
```{r remove_alt_chr}
desired_chromosomes <- paste0("chr",c(as.character(1:22), "X", "Y"))
# Assuming your GRanges object is called granges_obj
tss_gr <- tss_gr[seqnames(tss_gr) %in% desired_chromosomes]
length(tss_gr)
```
Now we'll reduce these to genes.

```{r pick-gene-tss, cache=TRUE}
# Split the TSS by gene
tss_by_gene <- split(tss_gr, tss_gr$gene_id)

# Find the correct TSS considering strand
min_tss_by_gene <- lapply(tss_by_gene, function(gr) {
                    
                      positive_strand <- gr[strand(gr) == "+"]
                      negative_strand <- gr[strand(gr) == "-"]
  
        # Get minimum for positive strand and maximum for negative strand
        pos_tss <- if (length(positive_strand) > 0)   positive_strand[which.min(start(positive_strand))] else NULL
        neg_tss <- if (length(negative_strand) > 0) negative_strand[which.max(start(negative_strand))] else NULL
  
        # Return Grange for object that isn't NULL
        if (!is.null(pos_tss)) return(pos_tss)
        if (!is.null(neg_tss)) return(neg_tss) 
        })

# Use unlist to combine the GRanges elements into a single GRanges object
min_tss_gr <- unlist(GRangesList(min_tss_by_gene))

# View the result
min_tss_gr

min_tss_gr <- keepSeqlevels(min_tss_gr, seqlevelsInUse(min_tss_gr), pruning.mode = "coarse")
#table(seqnames(min_tss_gr))
```

## We have `r length(min_tss_gr)` gene TSS sites

Is it correct to assume each gene is only on 1 strand? (I made that assumption)
If I'm wrong, then I've saved the positive strand only.

### `r sum(seqnames(min_tss_gr)=="chrX")` (`r round(mean(seqnames(min_tss_gr)=="chrX"),3)*100`\%) are on ChrX

### `r sum(seqnames(min_tss_gr)=="chrY")` (`r round(mean(seqnames(min_tss_gr)=="chrY"),3)*100`\%) are on ChrY


Let's note if the TSS is in a CpG island.
```{r overlap-cgi, message=FALSE}
rmarkdown::render("cpgi-regions.Rmd", quiet =TRUE)

f1 <- findOverlaps(min_tss_gr,cgi_gr)
f1
values(min_tss_gr)$TSSinCGI <- 0
values(min_tss_gr)$TSSinCGI[queryHits(f1)] <- 1
table(values(min_tss_gr)$TSSinCGI)
```

### `r as.character(sum(values(min_tss_gr)$TSSinCGI))` (`r round(mean(values(min_tss_gr)$TSSinCGI),2)*100`\%) of the TSSs are in UCSC defined CpG islands.


Clean levels of strand
```{r}
strand(min_tss_gr) <-  droplevels(strand(min_tss_gr))
table(strand(min_tss_gr))
```

I have no idea why this doesn't work!

```{r save-data}
save(min_tss_gr,file="data/min_tss_gr.rda")
```


```{r sI}
sessionInfo()
```

