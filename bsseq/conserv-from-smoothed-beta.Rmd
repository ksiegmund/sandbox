---
title: "Conservation from smoothed betas"
author: "ks"
date: "2025-09-05"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, message=FALSE}
library(GenomicRanges)
library(data.table)
library(ggplot2)
library(rtracklayer)
library(dplyr)
```

Darryl suggested generating a BED file of 1Mb region (1 million bases) around conserved sites (avg PWD < 0.1).

Let's smooth the sample beta value estimates by pooling m,u read counts in 500 bp intervals as recommended by NAR 2015 'DSS-single' paper.

Here is the list of sample names, their file locations and names.
Tumor M has the lowest average DNA methylation (0.54), suggesting the tumor might have the widest distribution of conservation. Tumor H would be another to try (mean DNAm = 0.57).
EN has highest coverage (median 23) compared to JN, IN (median 15, 13, respectively)

Sample EN, Chromosome 17 has 1083518 CpGs.
Ben berman summarizes mean DNAm by 5 adjacent CpGs on chromosome 4 (~1470693 CpGs) and and finds PMDs from 20-kb windows.

I will search for conservation in sliding 500bp windows.  



```{r data-files}
readdir <- c("~kims/Google Drive/My Drive/Data/hpc-archive/wg_bed/bed_files")
samplename <- c("MA","MB","IN","JN")
```


```{r get-list}
# Load the exclusion list file (for hg38, as an example)
# starting here https://github.com/Boyle-Lab/Blacklist?tab=readme-ov-file takes me
# https://www.encodeproject.org/annotations/ENCSR636HFF/
# and download https://www.encodeproject.org/files/ENCFF356LFX/
excludelist <- import("data/ENCFF356LFX.bed.gz")
```

```{r summarize-each-file}
read_bedfile <- 
      function(sample = "MA") {
          fin <- fread(file.path(readdir,paste0(sample,".bed")))
  
          setnames(fin, c("chr","start","end","beta","depth","m","u"))
          # filter on assembly
          desired_chromosomes <- paste0("chr",c(as.character(1:22),"X","Y"))
          fin <- fin[chr %in% desired_chromosomes]
          # filter on exclude list
  
          betav <- GRanges(seqnames = fin$chr,
                            IRanges(start = fin$start,end = fin$end))
          values(betav) <- DataFrame(m = fin$m, depth = fin$depth)

          s1 <- subsetByOverlaps(betav, excludelist, invert = TRUE)
          s1  
      }

calc_smoothed_beta <- 
  function(gr, chr="chr17", window_size = 500) {
      # Convert GRanges to data.table
       s1 <- as.data.table(gr)
       s1 <- s1[seqnames==chr]
       s1[, row_id := .I]
     

      half_window <- window_size / 2
      # Expand each interval by 250 bp in both directions
      s1[, `:=`(
           smooth_start = start - half_window,
             smooth_end = end + half_window
       )]
       # Create a copy for overlap comparison
      s1_overlap <- copy(s1)
      # Set keys for fast overlap join
      setkey(s1_overlap, seqnames, start, end)

      # Perform a self-join to find overlaps within the smoothed window
      hits <- foverlaps(
          s1[, .(row_id, seqnames, start = smooth_start, end = smooth_end)],
          s1_overlap[, .(row_id_match = row_id, seqnames, start, end, m, depth)],
          by.x = c("seqnames", "start", "end"),
          by.y = c("seqnames", "start", "end"),
          type = "any",
          nomatch = 0
      )

      # Now for each original row, compute total m and total depth from overlapping intervals
      rm(s1_overlap)
      smoothed_scores <- hits[, .(m_tot     = sum(m, na.rm = TRUE),
                                  depth_tot = sum(depth,na.rm=TRUE) ), by = row_id]

      # Merge smoothed scores back to original
      s1 <- merge(s1, smoothed_scores, by = "row_id", all.x = TRUE, sort = FALSE)
      table(s1$depth_tot>4)

      s1 <- s1[depth_tot > 4]
      s1$smoothed_beta <- s1$m_tot/s1$depth_tot
      s1
}

combine_paired_samples <- function (s1,s2, chr = thischr, window_size = 500) {
#  s1 <- "IA"
#  s2 <- "IB"
#  chr <- "chr18"
#  window_size <- 500
  
        s1.gr <- read_bedfile(sample=s1)
        s1_smoothed_beta <- calc_smoothed_beta(s1.gr,chr=chr,window_size=window_size)
 
        s2.gr <- read_bedfile(sample=s2)
        s2_smoothed_beta <- calc_smoothed_beta(s2.gr,chr=chr,window_size=window_size)

        setkey(s1_smoothed_beta, seqnames, start, end)
        setkey(s2_smoothed_beta, seqnames, start, end)
        
        dt <- merge(
                s1_smoothed_beta[, .(seqnames, start, end, s1.smoothed_beta = smoothed_beta, s1.depth_tot = depth_tot)],
                s2_smoothed_beta[, .(seqnames, start, end, s2.smoothed_beta = smoothed_beta, s2.depth_tot = depth_tot)],
                by.x = c("seqnames", "start", "end"),
                by.y = c("seqnames", "start", "end")
              )
        
        rm(s1.gr,s2.gr)
        
        dt$pwd      = abs(dt$s1.smoothed_beta - dt$s2.smoothed_beta)
        dt$avgdepth_tot = dt$s1.depth_tot + dt$s2.depth_tot
        dt$s12diff  = dt$s1.smoothed_beta - dt$s2.smoothed_beta
        dt$avgb     = (dt$s1.smoothed_beta + dt$s2.smoothed_beta)/2
        dt
}
```


A quick look at sequencing depth of the Y chromosomes suggests JN, IN are female and EN is male.

There are ~1.08x10^6 CpG sites in chr17. Let's start with that one. Intervals on end are kept if we have more than 5 reads regardless of whether interval only has data from 1/2 the intervals.  Chr17 contains TP53. 

I require that the tumor and normal are measured on the same CpG sites, to control for different sequencing depth of some tumors.  It would be faster to process these separately without this requirement. I could just process all pairs of samples and merge CpGs from the processed data before calling intervals. 
```{r smoothing-over-intervals}
pairs.lst <- list(
  c("MA","MB"),
  c("JN","IN")
)

pickchr <- "chr17"
dt_list <- list()

for (i in 1:length(pairs.lst)) {
          pair <- pairs.lst[[i]]
          pair 
          dt_list[[i]] <- combine_paired_samples(pair[1],
                                                 pair[2], chr=pickchr, 
                                                 window_size = 500)
}

# merge paired samples
        dtc <- merge(
                dt_list[[1]][, .(seqnames, start, end, 
                                 pair1.pwd  = pwd,
                                 pair1.avgdepth_tot = avgdepth_tot,
                                 pair1.diff = s12diff,
                                 pair1.avgb = avgb)],
                dt_list[[2]][, .(seqnames, start, end, 
                                 pair2.pwd  = pwd, 
                                 pair2.avgdepth_tot = avgdepth_tot,
                                 pair2.diff = s12diff,
                                 pair2.avgb = avgb)],

                by.x = c("seqnames", "start", "end"),
                by.y = c("seqnames", "start", "end")
              )
       
ndt <- names(dtc)  
ndt <- sub("pair1",paste0(pairs.lst[[1]][1],"_v_",pairs.lst[[1]][2]),ndt)
ndt <- sub("pair2",paste0(pairs.lst[[2]][1],"_v_",pairs.lst[[2]][2]),ndt)
names(dtc) <- ndt
```


```{r moreprs}
#        dttn <- merge(
#                dt_list[[3]][, .(seqnames, start, end, 
#                                 pair1.pwd  = pwd,
#                                 pair1.diff = s12diff,
#                                 pair1.avgb = avgb)],
#                dt_list[[4]][, .(seqnames, start, end, 
#                                 pair2.pwd  = pwd, 
#                                 pair2.diff = s12diff,
#                                 pair2.avgb = avgb)],

#                by.x = c("seqnames", "start", "end"),
#                by.y = c("seqnames", "start", "end")
#              )
#ndt <- names(dttn)  
#ndt <- sub("pair1",paste0(pairs.lst[[3]][1],"_v_",pairs.lst[[3]][2]),ndt)
#ndt <- sub("pair2",paste0(pairs.lst[[4]][1],"_v_",pairs.lst[[4]][2]),ndt)
#names(dttn) <- ndt
```

There are `r nrow(dtc)` CpGs measured in each paired sample.

```{r merge}
dim(dtc)
#dim(dttn)
```

```{r symmetry}
hist(dtc$MA_v_MB.diff)
hist(dtc$JN_v_IN.diff)
#hist(dttn$IA_v_IN.diff)
#hist(dttn$IB_v_IN.diff)
```



```{r density-plot1}
ggplot(dtc, aes(x = JN_v_IN.avgb)) +
  geom_density(fill = "skyblue", alpha = 0.5) +
  labs(
    title = "Density Plot of Average Beta in Non-tumor colon",
    x = "Beta value",
    y = "Density"
  ) +
  theme_minimal()
```

```{r plot2}
ggplot(dtc, aes(x = MA_v_MB.avgb)) +
  geom_density(fill = "skyblue", alpha = 0.5) +
  labs(
    title = "Density Plot of Average Beta in Tumor M",
    x = "Beta value",
    y = "Density"
  ) +
  theme_minimal()
```

```{r plot3}
ggplot(dtc, aes(x = MA_v_MB.pwd)) +
  geom_density(fill = "skyblue", alpha = 0.5) +
  labs(
    title = "Density Plot of PWD in Tumor M",
    x = "Beta value",
    y = "Density"
  ) +
  theme_minimal()
```

```{r plot4}
ggplot(dtc, aes(x = JN_v_IN.pwd)) +
  geom_density(fill = "skyblue", alpha = 0.5) +
  labs(
    title = "Density Plot of PWD in non-tumor colon",
    x = "Beta value",
    y = "Density"
  ) +
  theme_minimal()
```

## Plot of smoothed betas along genomic coordinates


```{r}
ggplot(dtc[5001:10000], aes(x = start, y = JN_v_IN.avgb)) +
  geom_point(alpha = 0.5, size = 0.7) +
  labs(
    title = "Average Beta in Normal Tissue (JN,IN)",
    x = "Genomic Position",
    y = "Average Beta"
  ) +
  theme_minimal()
```

Cool! P53 is here: 7,661,779-7,687,538 (25,760 bp)

```{r pwd-in-normal}
ggplot(dtc[5001:10000], aes(x = start, y = JN_v_IN.pwd)) +
  geom_point(alpha = 0.5, size = 0.7) +
  geom_smooth(method = "gam") +
  labs(
    title = "PWD in Normal Tissue (JN,IN)",
    x = "Genomic Position",
    y = "PWD"
  ) +
  theme_minimal()
```

```{r same-in-tumor}
ggplot(dtc[5001:10000], aes(x = start, y = MA_v_MB.avgb)) +
  geom_point(alpha = 0.5, size = 0.7) +
  #geom_smooth(method = "gam") +
  labs(
    title = "Average Beta in Tumor (MA,MB)",
    x = "Genomic Position",
    y = "Average Beta"
  ) +
  theme_minimal()
```

That's also cool. The right side looks like a partially methylated domain. Is the DNAm conserved?


```{r pwd-in-tumor}
ggplot(dtc[5001:10000], aes(x = start, y = MA_v_MB.pwd)) +
  geom_point(alpha = 0.5, size = 0.7) +
  geom_smooth(method = "gam") +
  labs(
    title = "PWD in Tumor (MA,MB)",
    x = "Genomic Position",
    y = "PWD"
  ) +
  theme_minimal()
```

The left side of the figure shows more conservation than the right side.

## Define Conserved Regions

The smoothed betas have been estimated using all CpGs in a window of 500 bps and requiring a depth of 5+ reads from that interval, so they are more stable than beta values from single CpGs. Let's look at the distribution of PWD from the smoothed beta values and pick a cutoff for defining conservation. 

```{r summarize}
print("Tumor M PWD")
summary(dtc$MA_v_MB.pwd)
print("Normal J,I PWD")
summary(dtc$JN_v_IN.pwd)
mpwd <- median(dtc$JN_v_IN.pwd)
```
The within tumor PWD is less than the between normal PWD.

I will use the median PWD in normal tissue to define conservation. This is more stringent than the 0.05 cutoff we've used in the past.

Definition of conserved region:  
1. (smoothed) CpG PWD < median(PWD JN vs IN) (= `r round(mpwd,3)`)  
2. 4+ neighboring conserved CpGs  
3. minimum width 201 bps

```{r define-intervals}
find_Intervals_of_conserv <- function(dtc,ncg=4, minwidth=200, pwd = "MA_v_MB.pwd",
                                      mpwd = median(dtc$JN_v_IN.pwd)){
    dtc$consv <- ifelse(dtc[, ..pwd] < mpwd,1,0)

    # compute run-lengths of 1/0s
    Mc <- rle(dtc$consv)
    # assign unique IDs to the different intervals
    intID <- rep(1:length(Mc$values), Mc$lengths)
    # if the values are 0, assign ID name 0
    intID <- intID * dtc$consv
    # count number of CpGs per interval
    tc <- table(intID)
    
    print(paste("Number of intervals:",length(tc)))
    print("Distribution of num CpGs per interval:")
    print(summary(as.vector(tc[-1]))) #exclude count for intID=0 (1st element of vector)
    
    # get the intID for intervals with fewer than ncg and assign ID 0
    shortint <- names(tc)[tc<ncg]
    intIDf <- ifelse(is.element(intID,shortint),0,intID)
    dtc$intIDf <- intIDf
    
    # subset to conserved CpGs (those with positive ID numbers)
    # get bed file format of conserved regions
    dtcf.sum <- dtc[intIDf > 0 , .(start = min(start),
                                   end   = max(end),
                                 AvB.pwd = mean(get(pwd), na.rm=T),
                                   n_CpG = .N), by = .(intIDf, seqnames)]
    # add widths 
    dtcf.sum$width <- dtcf.sum$end-dtcf.sum$start
    # summarize interval widths
    print("Interval widths")
    print(summary(dtcf.sum$width))
    # requires intervals have minimum minwidth bps 
    print(paste("require minimum width of",minwidth))
    dtcf.sum <- dtcf.sum[ width > minwidth, ]
    print(paste("Number of intervals remaining:",nrow(dtcf.sum)))
    print(paste("# intervals/ original # CpGs:",round(nrow(dtcf.sum)/nrow(dtc),3)))
    dtcf.sum
}
```

### Tumor M
```{r consv-intervals}
TumorM.dt<- find_Intervals_of_conserv(dtc,pwd = "MA_v_MB.pwd")
```
Interesting. I think that proportion is similar to the proportion of genome that is coding regions. Not what we're computing here though.

Let's find the interval with the most CpGs.
```{r mostCpGs}
TumorM.dt[ n_CpG == max(n_CpG),]
```

Now let's find the widest interval.
```{r widest}
TumorM.dt[ width == max(width),]
```

## Plot (smoothed) Beta Values for conserved regions


```{r data, echo=FALSE}
MA.gr <- read_bedfile("MA")
MA.dt <- calc_smoothed_beta(MA.gr, chr="chr17", window_size = 500)
MB.gr <- read_bedfile("MB")
MB.dt <- calc_smoothed_beta(MB.gr, chr="chr17", window_size = 500)
rm(MA.gr,MB.gr)

IN.gr <- read_bedfile("IN")
IN.dt <- calc_smoothed_beta(IN.gr, chr="chr17", window_size = 500)
JN.gr <- read_bedfile("JN")
JN.dt <- calc_smoothed_beta(JN.gr, chr="chr17", window_size = 500)
rm(IN.gr,JN.gr)
```


Handpick intervals to see the differences in conservation.

```{r plot-region, echo=FALSE}
plot_region <- function(pos1=81510412, posn = 81515609) {
      sMA <- MA.dt[MA.dt$start > (pos1 - 1) & MA.dt$end < (posn + 1),]
      sMB <- MB.dt[MB.dt$start > (pos1 - 1) & MB.dt$end < (posn + 1),]
      sIN <- IN.dt[IN.dt$start > (pos1 - 1) & IN.dt$end < (posn + 1),]
      sJN <- JN.dt[JN.dt$start > (pos1 - 1) & JN.dt$end < (posn + 1),]
      sMA$sample <- "MA"
      sMB$sample <- "MB"
      sIN$sample <- "IN"
      sJN$sample <- "JN"
      long.df <- rbind.data.frame(sMA,sMB,sIN,sJN)
      long.df$sample <- as.factor(long.df$sample)
      
      ggplot(data=long.df, aes(x=start, y=smoothed_beta, group = sample, color = sample)) +
          geom_line() + 
          geom_point()
}
```



Plot the region with the most CpGs.
```{r plot1-region1}
plot_region(pos1 = 81510412, posn = 81515609)
```

Yes, that's a long conserved region (~ `r 81515609-81510412` bps)

What about the very long region of just 8 CpGs?

```{r plot-region2}
plot_region(pos1 = 960711, posn = 1062787)
```

This looks like some irregular sequencing data.  How many such intervals are there (wide with few CpGs)?
```{r}
ggplot(TumorM.dt, aes( x = n_CpG, y = width)) +
    geom_point()
```


Try cluster analysis to identify outliers
```{r}
set.seed(30)
kmgps <- stats::kmeans(TumorM.dt[,.(n_CpG,width)],centers=2,nstart = 200)
table(kmgps$cluster)
ggplot(TumorM.dt, aes( x = n_CpG, y = width, color = factor(kmgps$cluster))) +
    geom_point()
```

```{r filter-outliers}
#TumorM.dt <- TumorM.dt[kmgps$cluster==2,]
set.seed(418)
kmgps <- stats::kmeans(TumorM.dt[,.(n_CpG,width)],centers=2,nstart = 200)
table(kmgps$cluster)
ggplot(TumorM.dt, aes( x = n_CpG, y = width, color = factor(kmgps$cluster))) +
    geom_point()
```

I will drop intervals with width > 7500
```{r drop-bigwidths}
TumorM.dt <- TumorM.dt[width < 7500	,]
nrow(TumorM.dt)
```

```{r}
ggplot(TumorM.dt, aes( x = n_CpG, y = width)) +
    geom_point()
```
I plan to send Darryl those with minimum 100 CpGs.

Let's find intervals conserved in Normal (tidy), and then identify Tumor M intervals that overlap Normal intervals vs distinct.

### Normal-Normal (JN,IN)
```{r consv-intervals}
nn.dt<- find_Intervals_of_conserv(dtc,pwd = "JN_v_IN.pwd")
```

```{r mostCpGs}
nn.dt[ n_CpG == max(n_CpG),]
```

Plot the region with the most CpGs.
```{r plot1-region1}
plot_region(pos1 = 8117738, posn = 8127638)
```


```{r}
ggplot(nn.dt, aes( x = n_CpG, y = width)) +
    geom_point()
```

Try cluster analysis to identify outliers
```{r}
set.seed(30)
kmgps <- stats::kmeans(nn.dt[,.(n_CpG,width)],centers=2,nstart = 200)
table(kmgps$cluster)
ggplot(nn.dt, aes( x = n_CpG, y = width, color = factor(kmgps$cluster))) +
    geom_point()
```


```{r}
nn.dt <- nn.dt[kmgps$cluster==2,]
set.seed(4)
kmgps <- stats::kmeans(nn.dt[,.(n_CpG,width)],centers=2,nstart = 200)
table(kmgps$cluster)
ggplot(nn.dt, aes( x = n_CpG, y = width, color = factor(kmgps$cluster))) +
    geom_point()
```

Hmmm. I don't want to toss the interval with > 500 CpGs. That plot looked fine earlier.  I will filter on width < 10000.

```{r}
nn.dt <- nn.dt[width < 10000,]
ggplot(nn.dt, aes( x = n_CpG, y = width)) +
    geom_point()
```
Let's overlap TumorM with normal-normal.
```{r overlap}
TumorM.gr <- GRanges(seqnames=TumorM.dt$seqnames,
                     IRanges(start = TumorM.dt$start,end = TumorM.dt$end))
values(TumorM.gr) <- DataFrame(id = TumorM.dt$intIDf,
                                apwd = TumorM.dt$AvB.pwd,
                                ncpg = TumorM.dt$n_CpG)


nn.gr <- GRanges(seqnames=nn.dt$seqnames,
                     IRanges(start = nn.dt$start,end = nn.dt$end))
values(nn.gr) <- DataFrame(id = nn.dt$intIDf,
                                apwd = nn.dt$AvB.pwd,
                                ncpg = nn.dt$n_CpG)


TumorMonly <- subsetByOverlaps(TumorM.gr, nn.gr, invert = TRUE)
commonRegions <- subsetByOverlaps(TumorM.gr, nn.gr)
```

summarize
```{r}
summary(width(TumorMonly))
summary(width(commonRegions))
```


```{r}
commonRegions
```

7,661,779-7,687,538 (width = 25759 kb)
```{r}
tp53 <- GRanges(seqnames="chr17",
                     IRanges(start = 7661779,end = 7687538))
subsetByOverlaps(commonRegions,tp53)
```

tp53 contains several intervals that are conserved in tumor & normal. Let's analyze distribution between intervals and merge intervals that are close.


```{r}

```



```{r sI}
sessionInfo()
```

